<!DOCTYPE html>
<html>

<script type="text/javascript">
var _hmt = _hmt || [];
(function() {
  var hm = document.createElement("script");
  hm.src = "//hm.baidu.com/hm.js?639ab28f32e0029ed25324113f0ff34a";
  var s = document.getElementsByTagName("script")[0]; 
  s.parentNode.insertBefore(hm, s);
})();
</script>


<head>
  <meta charset="utf-8">
  
  <title>什么是 Web 框架? | 运维生存时间</title>
  <meta name="viewport" content="width=device-width, initial-scale=1, maximum-scale=1">
  <meta name="description" content="web framework">
<meta property="og:type" content="article">
<meta property="og:title" content="什么是 Web 框架?">
<meta property="og:url" content="http://ttlop.com/2016/06/17/什么是-Web-框架/index.html">
<meta property="og:site_name" content="运维生存时间">
<meta property="og:description" content="web framework">
<meta property="og:updated_time" content="2016-06-17T03:31:52.411Z">
<meta name="twitter:card" content="summary">
<meta name="twitter:title" content="什么是 Web 框架?">
<meta name="twitter:description" content="web framework">
  
    <link rel="alternate" href="/atom.xml" title="运维生存时间" type="application/atom+xml">
  
  
    <link rel="icon" href="/favicon.png">
  
  
    <link href="//fonts.googleapis.com/css?family=Source+Code+Pro" rel="stylesheet" type="text/css">
  
  <link rel="stylesheet" href="/css/style.css">
  

</head>

<body>
  <div id="container">
    <div id="wrap">
      <header id="header">
  <div id="banner"></div>
  <div id="header-outer" class="outer">
    <div id="header-title" class="inner">
      <h1 id="logo-wrap">
        <a href="/" id="logo">运维生存时间</a>
      </h1>
      
        <h2 id="subtitle-wrap">
          <a href="/" id="subtitle">业精于勤而荒于嬉，行成于思而毁于随</a>
        </h2>
      
    </div>
    <div id="header-inner" class="inner">
      <nav id="main-nav">
        <a id="main-nav-toggle" class="nav-icon"></a>
        
          <a class="main-nav-link" href="/">Home</a>
        
          <a class="main-nav-link" href="/archives">Archives</a>
        
          <a class="main-nav-link" href="/About">About</a>
        
      </nav>
      <nav id="sub-nav">
        
          <a id="nav-rss-link" class="nav-icon" href="/atom.xml" title="RSS Feed"></a>
        
        <a id="nav-search-btn" class="nav-icon" title="Search"></a>
      </nav>
      <div id="search-form-wrap">
        <form action="//google.com/search" method="get" accept-charset="UTF-8" class="search-form"><input type="search" name="q" results="0" class="search-form-input" placeholder="Search"><button type="submit" class="search-form-submit">&#xF002;</button><input type="hidden" name="sitesearch" value="http://ttlop.com"></form>
      </div>
    </div>
  </div>
</header>
      <div class="outer">
        <section id="main"><article id="post-什么是-Web-框架" class="article article-type-post" itemscope itemprop="blogPost">
  <div class="article-meta">
    <a href="/2016/06/17/什么是-Web-框架/" class="article-date">
  <time datetime="2016-06-17T01:47:23.000Z" itemprop="datePublished">2016-06-17</time>
</a>
    
  <div class="article-category">
    <a class="article-category-link" href="/categories/Web/">Web</a>
  </div>

  </div>
  <div class="article-inner">
    
    
      <header class="article-header">
        
  
    <h1 class="article-title" itemprop="name">
      什么是 Web 框架?
    </h1>
  

      </header>
    
    <div class="article-entry" itemprop="articleBody">
      
        <p>Web 应用框架，或者简单的说是 “Web 框架”，其实是建立 Web 应用的一种方式。从简单的博客系统到复杂的 AJAX 应用，Web 上每个页面都是通过代码来产生的。很多人热衷于学习 Web 框架技术，但并不理解什么是 Web 框架，或者它们是如何工作的。这里，我们将探讨反复被忽略的 Web 框架基础的话题。阅读完这篇文章，你应该对什么是 Web 框架以及它们为什么会存在有更深的认识。这会让你学习一个新的 Web 框架变的简单的多，还会让你使用不同的框架的时候作出明智的选择。</p>
<a id="more"></a>
<h2 id="1-Web-如何工作？"><a href="#1-Web-如何工作？" class="headerlink" title="1. Web 如何工作？"></a>1. Web 如何工作？</h2><p>在我们讨论框架钱，我们需要理解 Web 如何“工作”的。为此，我们将深入挖掘你在浏览器里输入一个 URL 按下 Enter 之后都发生了什么。在你的浏览器打开一个新的标签，浏览 <a href="http://ttlop.com">http://ttlop.com</a> 。我们讨论为了显示这个页面，浏览器都做了什么（不关心 DNS 查询）。</p>
<h3 id="1-1-Web-服务器"><a href="#1-1-Web-服务器" class="headerlink" title="1.1 Web 服务器"></a>1.1 Web 服务器</h3><p>每个页面都以 HTML 的形式传送到你的浏览器中，HTML 是一种浏览器用来描述页面内容和结构的语言。那些负责发送 HTML 到浏览器的应用称之为 “Web服务器”，会让你感到疑惑的是，这些应用运行的机器通常也叫做 Web 服务器。</p>
<p>然而，最重要的是要理解，到最后所有的 Web 应用要做的事情就是发送 HTML 到浏览器。不管应用的逻辑多么复杂，最终的结果总是将 HTML 发送到浏览器。</p>
<p>Web 应用如何知道发送什么到浏览器？它发送浏览器请求的任何东西。</p>
<h4 id="1-1-1-HTTP"><a href="#1-1-1-HTTP" class="headerlink" title="1.1.1 HTTP"></a>1.1.1 HTTP</h4><p>浏览器从 Web 服务器（或者叫做应用服务器）上使用 HTTP 协议下载网站，HTTP 协议是基于请求-响应（request-response）模型的。客户端（你的浏览器）从运行在物理机器上的 Web 应用请求数据，Web 应用反过来对你的浏览器进行响应。</p>
<p>重要的一点是，要记住通信总是由客户端（你的浏览器）发起的，服务器（也就是 Web 服务器）没有办法创建一个链接，发送没有经过请求的数据给你的浏览器。如果你从 Web 服务器上接收到数据，一定是因为你的浏览器显示的发送了请求。</p>
<h4 id="1-1-2-HTTP-Method"><a href="#1-1-2-HTTP-Method" class="headerlink" title="1.1.2 HTTP Method"></a>1.1.2 HTTP Method</h4><p>在 HTTP 协议中，每条报文都关联方法（method），不同的 HTTP 方法对应客户端可以发送逻辑上不同类型的请求，反过来也代表了客户端的不同意图。例如，请求一个 Web 页面的 HTML，与提交一个表单在逻辑上是不同的，所以这两种行为就需要使用不同的方法。</p>
<h5 id="HTTP-GET"><a href="#HTTP-GET" class="headerlink" title="*. HTTP GET"></a>*. HTTP GET</h5><p>GET 方法就像其听起来的那样，从 Web 服务器上 get（请求）数据。GET 请求是到目前为止最常见的一种 HTTP 请求，在一次 GET 请求过程中，Web 应用对请求页面的 HTML 进行响应之外，就不需要做任何事情了。特别要注意的是，Web 应用在 GET 请求的结果中，不应该改变应用的的状态（比如，不能基于 GET 请求创建一个新帐号）。正在因为这个原因，GET 请求通常认为是“安全”的，因为他们不会导致应用的改变。</p>
<h5 id="HTTP-POST"><a href="#HTTP-POST" class="headerlink" title="*. HTTP POST"></a>*. HTTP POST</h5><p>显然，除了简单的查看页面之外，应该还有更多与网站进行交互的操作。我们也能够向应用发送数据，例如提交表单。为了达到这样的目的，就需要一种不同类型的请求方法：POST。POST 请求通常携带由用户输入的数据，Web 应用收到之后会产生一些行为。通过在表单里输入你的信息登录一个网站，就是 POST 表单的数据给 Web 应用的。</p>
<p>不同于 Get 请求，POST 请求通常会导致应用状态的改变。POST 请求不总是生成一个新的 HTML 页面发送到客户端，而是客户端使用相应的响应码（response code）来判断对应用的操作是否成功。</p>
<h4 id="1-1-3-HTTP-Response-Codes"><a href="#1-1-3-HTTP-Response-Codes" class="headerlink" title="1.1.3 HTTP Response Codes"></a>1.1.3 HTTP Response Codes</h4><p>通常来说，Web 服务器返回 200 的响应码，意思是“我已经完成了你要求我做的事情，一切都正常”。响应码总是一个三位数的代号，Web 应用在每个响应的同时都发送一个这样的代号，表明给定的请求的结果。响应码 200 字面意思是“OK”，是响应一个 GET 请求大多情况下都使用的代号。然而对于 POST 请求，可能会有 204 发送回来，意思是“一切都正常，但是我不准备向你显示任何东西”。</p>
<p>POST 请求仍然会发送一个特殊的 URL，这个 URL 可能和提交数据的页面不同，意识这一点是至关重要的。POST 请求要发送的位置在表单的 HTML 中有特别标明。</p>
<h3 id="1-2-Web-应用"><a href="#1-2-Web-应用" class="headerlink" title="1.2 Web 应用"></a>1.2 Web 应用</h3><p>你可以仅仅使用 HTTP GET 和 POST 做很多事情。一个应用程序负责去接收一个 HTTP 请求，同时给予 HTTP 响应，通常包含了请求页面的 HTML。POST 请求会引起 Web 应用做一些行为，可能是在数据库中添加一条记录这样的。还有很多其它的 HTTP 方法，但是我们目前只关注 GET 和 POST。</p>
<p>那么最简单的 Web 应用是什么样的呢？我们可以写一个应用，让它一直侦听 80 端口（著名的 HTTP 端口，几乎所有 HTTP 都发送到这个端口上）。一旦它接收到客户端发送的请求链接，就会回复一些简单的 HTML。</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br></pre></td><td class="code"><pre><span class="line">import socket</span><br><span class="line">HOST = &apos;&apos;</span><br><span class="line">PORT = 80</span><br><span class="line">listen_socket = socket.socket(socket.AF_INET, socket.SOCK_STREAM)</span><br><span class="line">listen_socket.bind((HOST, PORT))</span><br><span class="line">listen_socket.listen(1)</span><br><span class="line">connection, address = listen_socket.accept()</span><br><span class="line">request = connection.recv(1024)</span><br><span class="line">connection.sendall(b&quot;&quot;&quot;HTTP/1.1 200 OK</span><br><span class="line">Content-type: text/html</span><br><span class="line"></span><br><span class="line">&lt;html&gt;</span><br><span class="line">    &lt;body&gt;</span><br><span class="line">        &lt;h1&gt;Hello, World!&lt;/h1&gt;</span><br><span class="line">    &lt;/body&gt;</span><br><span class="line">&lt;/html&gt;&quot;&quot;&quot;)</span><br><span class="line">connection.close()</span><br></pre></td></tr></table></figure>
<p>（如果上面的代码不工作，试着将 PORT 改为类似 8080 这样的端口。）</p>
<p>这个代码接收简单的链接和简单的请求，不管请求的 URL 是什么，它都会响应 HTTP 200（所以这不是一个真正意义上的 web 服务器）。</p>
<h4 id="1-2-1-请求的剖析"><a href="#1-2-1-请求的剖析" class="headerlink" title="1.2.1 请求的剖析"></a>1.2.1 请求的剖析</h4><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line">[root@localhost ~]# curl -i http://localhost:8080</span><br><span class="line">HTTP/1.1 200 OK</span><br><span class="line">Content-type: text/html</span><br><span class="line"></span><br><span class="line">&lt;html&gt;</span><br><span class="line">    &lt;body&gt;</span><br><span class="line">        &lt;h1&gt;Hello, World!&lt;/h1&gt;</span><br><span class="line">    &lt;/body&gt;</span><br><span class="line">&lt;/html&gt;</span><br></pre></td></tr></table></figure>
<p>测试上面的 HTTP 请求，你会发现它和 HTTP 响应非常类似。第一行 HTTP Method、URL、 HTTP Version。这个例子是 HTTP/1.1。第一行之后就是一些类似 Accpet: <em>/</em> 这样的头（意思是我们希望在响应中接受任何内容）。</p>
<p>我们的响应和请求有着类似的第一行，接下来是头部，与请求的头部有着相同的格式。最后是响应的实际包含的内容。注意：这会被解释为一个字符串或者二进制文件，Content-type 头告诉客户端怎样去解释响应。</p>
<h2 id="2-Web-服务器之殇"><a href="#2-Web-服务器之殇" class="headerlink" title="2. Web 服务器之殇"></a>2. Web 服务器之殇</h2><p>如果我们继续以上面的例子为基础创建 Web 应用，我们还需要解决很多问题：</p>
<ol>
<li>我们怎样检查请求的 URL 以及返回正确的页面？</li>
<li>除了简单的 GET 请求之外我们如何处理 POST 请求？</li>
<li>我们如何理解更高级的概念，如 session 和 cookie？</li>
<li>我们如何扩展程序使其处理上千个并发连接？</li>
</ol>
<p>就像你想的那样，没人愿意每次建立一个 web 应用都要解决这些问题。正是这个原因，就有处理 HTTP 协议本身和有效处理上面问题的办法的包存在。然后，记住了，它们的核心功能和我们的例子是相同的：侦听请求，带有一些 HTML 发回 HTTP 响应。</p>
<h3 id="2-1-解决两大问题"><a href="#2-1-解决两大问题" class="headerlink" title="2.1 解决两大问题"></a>2.1 解决两大问题</h3><p>围绕建立 Web 应用的所有问题中，两个问题尤其突出：</p>
<ol>
<li>我们如何将请求的 URL 映射到处理它的代码上？</li>
<li>我们怎样动态的构造请求的 HTML 返回给客户端，HTML 中带有计算得到的值或者从数据库中取出来的信息？</li>
</ol>
<p>每个 web 框架都是以某种方法来解决这些问题，也有很多不同的解决方法。用例子来说更容易理解，所以针对这些问题我们讨论 Django 和 Flask 的解决方案。但是，首先我们还需要简单讨论一下 MVC。</p>
<h4 id="2-1-1-Django-中的-MVC"><a href="#2-1-1-Django-中的-MVC" class="headerlink" title="2.1.1 Django 中的 MVC"></a>2.1.1 Django 中的 MVC</h4><p>Django 充分利用了 MVC 设计模式。MVC，也就是 Model-View-Controller（模型-视图-控制器）是一种将应用的不同功能从逻辑上划分开。models 代表是类似数据库表的资源（与 Python 中用 class 来对真实世界目标建模使用的方法大体相同）。controls 包括应用的业务逻辑，对 models 进行操作。为了动态生成代表页面的 HTML，需要 views 给出所有要动态生成页面的 HTML 的信息。</p>
<p>在 Django 中有点让人困惑的是，Controllers 被称作 views，而 views 被称为 templates。除了名字有点奇怪，Django 很好地实现了 MVC 的体系架构。</p>
<h4 id="2-1-2-Django-中的路由"><a href="#2-1-2-Django-中的路由" class="headerlink" title="2.1.2 Django 中的路由"></a>2.1.2 Django 中的路由</h4><p>路由是处理请求 URL 到负责生成相关的 HTML 的代码之间映射的过程。在简单的情形下，所有的请求都是有相同的代码来处理（就像我们之前的例子那样）。变得稍微复杂一点，每个 URL 对应一个 view function 。举例来说，如果请求 www.foo.com/bar 这样的 URL，调用 handler_bar() 这样的函数来产生响应。我们可以建立这样的映射表，枚举出我们应用支持的所有 URL 与它们相关的函数。</p>
<p>然而，当 URL 中包含有用的数据，例如资源的 ID（像这样 www.foo.com/users/3/） ，那么这种方法将变得非常臃肿。我们如何将 URL 映射到一个 view 函数，同时如何利用我们想显示 ID 为 3 的用户？</p>
<p>Django 的答案是，将 URL 正则表达式映射到可以带参数的 view 函数。例如，我假设匹配^/users/(?P<id>\d+)/$ 的 URL 调用 display_user(id) 这样的函数，这儿参数 id 是正则表达式中匹配的 id。这种方法，任何 /users/<some_number>/ 这样的 URL 都会映射到 display_user 函数。这些正则表达式可以非常复杂，包含关键字和参数。</some_number></id></p>
<h4 id="2-1-3-Flask-中的路由"><a href="#2-1-3-Flask-中的路由" class="headerlink" title="2.1.3 Flask 中的路由"></a>2.1.3 Flask 中的路由</h4><p>Flask 采取了一点不同的方法。将一个函数和请求的 URL 关联起来的标准方法是通过使用 route() 装饰器。下面是 Flask 代码，在功能上和上面正则表达式方法相同：</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">@app.route(&apos;/users/&lt;id:int&gt;/&apos;)</span><br><span class="line">def display_user(id):</span><br><span class="line">    # ...</span><br></pre></td></tr></table></figure>
<p>就像你看到的这样，装饰器使用几乎最简单的正则表达式的形式来将 URL 映射到参数。通过传递给route() 的 URL 中包含的 <name:type> 指令，可以提取到参数。路由像 /info/about_us.html 这样的静态 URL，可以像你预想的这样 @app.route(‘/info/about_us.html’) 处理。</name:type></p>
<h4 id="2-1-4-通过-Templates-产生-HTML"><a href="#2-1-4-通过-Templates-产生-HTML" class="headerlink" title="2.1.4 通过 Templates 产生 HTML"></a>2.1.4 通过 Templates 产生 HTML</h4><p>继续上面的例子，一旦我们有合适的代码映射到正确的 URL，我们如何动态生成 HTML？对于 Django 和 Flask，答案都是通过 HTML Templating。</p>
<p>HTML Templating 和使用 str.format() 类似：需要动态输出值的地方使用占位符填充，这些占位符后来通过 str.format() 函数用参数替换掉。想象一下，整个 web 页面就是一个字符串，用括号标明动态数据的位置，最后再调用 str.format() 。Django 模板和 Flask 使用的模板引擎 Jinja2 都使用的是这种方法。</p>
<p>然而，不是所有的模板引擎都能相同的功能。Django 支持在模板里基本的编程，而 Jinja2 只能让你执行特定的代码（不是真正意义上的代码，但也差不多）。Jinja2 可以缓存渲染之后的模板，让接下来具有相同参数的请求可以直接从缓存中返回结果，而不是用再次花大力气渲染。</p>
<h4 id="2-1-5-数据库交互"><a href="#2-1-5-数据库交互" class="headerlink" title="2.1.5 数据库交互"></a>2.1.5 数据库交互</h4><p>Django 有着“功能齐全”的设计哲学，其中包含了一个 ORM(Object Realational Mapper，对象关系映射)，ORM 的目的有两方面：一是将 Python 的 class 与数据库表建立映射，二是剥离出不同数据库引擎直接的差异。没人喜欢 ORM，因为在不同的域之间映射永远不完美，然而这还在承受范围之内。Django 是功能齐全的，而 Flask 是一个微框架，不包括 ORM，尽管它对 SQLAlchemy 兼容性非常好，SQLAlchemy 是 Django ORM 的最大也是唯一的竞争对手。</p>
<p>内嵌 ORM 让 Django 有能力创建一个功能丰富的 CRUD 应用，从服务器端角度来看，CRUD（CreateRead Update Delete）应用非常适合使用 web 框架技术。Django 和 Flask-SQLchemy 可以直接对每个 model 进行不同的 CRUD 操作。</p>
<h2 id="3-再谈-Web-框架"><a href="#3-再谈-Web-框架" class="headerlink" title="3. 再谈 Web 框架"></a>3. 再谈 Web 框架</h2><p>到现在为止，web 框架的目的应该非常清晰了：向程序员隐藏了处理 HTTP 请求和响应相关的基础代码。至于隐藏多少这取决于不同的框架，Django 和 Flask 走向了两个极端：Django 包括了每种情形，几乎成了它致命的一点；Flask 立足于“微框架”，仅仅实现 web 应用需要的最小功能，其它的不常用的 web 框架任务交由第三方库来完成。</p>
<p>但是最后要记住的是，Python web 框架都以相同的方式工作的：它们接收 HTTP 请求，分派代码，产生 HTML，创建带有内容的 HTTP 响应。事实上，所有主流的服务器端框架都以这种方式工作的（ JavaScript 框架除外）。但愿了解了这些框架的目的，你能够在不同的框架之间选择适合你应用的框架进行开发。</p>
<blockquote>
<p>原文地址：<a href="http://www.jeffknupp.com/blog/2014/03/03/what-is-a-web-framework/" target="_blank" rel="external">http://www.jeffknupp.com/blog/2014/03/03/what-is-a-web-framework/</a><br>转载地址：<a href="http://www.cnblogs.com/hazir/p/what_is_web_framework.html" target="_blank" rel="external">http://www.cnblogs.com/hazir/p/what_is_web_framework.html</a></p>
</blockquote>

      
    </div>
    <footer class="article-footer">
      <a data-url="http://ttlop.com/2016/06/17/什么是-Web-框架/" data-id="civywpvx400a1copvvldc8umz" class="article-share-link">Share</a>
      
      
    </footer>
  </div>
  
    
<nav id="article-nav">
  
    <a href="/2016/06/20/Nagios-Installing-Nagios-Core-From-Source/" id="article-nav-newer" class="article-nav-link-wrap">
      <strong class="article-nav-caption">Newer</strong>
      <div class="article-nav-title">
        
          Nagios - Installing Nagios Core From Source
        
      </div>
    </a>
  
  
    <a href="/2016/06/16/MikroTik-基于-IPv6-的-6to4-通道/" id="article-nav-older" class="article-nav-link-wrap">
      <strong class="article-nav-caption">Older</strong>
      <div class="article-nav-title">MikroTik 基于 IPv6 的 6to4 通道</div>
    </a>
  
</nav>

  
</article>

</section>
        
          <aside id="sidebar">
  
    
  <div class="widget-wrap">
    <h3 class="widget-title">Categories</h3>
    <div class="widget">
      <ul class="category-list"><li class="category-list-item"><a class="category-list-link" href="/categories/Apache/">Apache</a></li><li class="category-list-item"><a class="category-list-link" href="/categories/Bat/">Bat</a></li><li class="category-list-item"><a class="category-list-link" href="/categories/Centos-7/">Centos 7</a></li><li class="category-list-item"><a class="category-list-link" href="/categories/HUAWEI/">HUAWEI</a></li><li class="category-list-item"><a class="category-list-link" href="/categories/Hadoop/">Hadoop</a></li><li class="category-list-item"><a class="category-list-link" href="/categories/Hexo/">Hexo</a></li><li class="category-list-item"><a class="category-list-link" href="/categories/Hyper-V/">Hyper-V</a></li><li class="category-list-item"><a class="category-list-link" href="/categories/Iptables/">Iptables</a></li><li class="category-list-item"><a class="category-list-link" href="/categories/Linux/">Linux</a></li><li class="category-list-item"><a class="category-list-link" href="/categories/Microsoft-SQL-Server/">Microsoft SQL Server</a></li><li class="category-list-item"><a class="category-list-link" href="/categories/MikroTik/">MikroTik</a></li><li class="category-list-item"><a class="category-list-link" href="/categories/Mysql/">Mysql</a></li><li class="category-list-item"><a class="category-list-link" href="/categories/Nagios/">Nagios</a></li><li class="category-list-item"><a class="category-list-link" href="/categories/Nginx/">Nginx</a></li><li class="category-list-item"><a class="category-list-link" href="/categories/PHP/">PHP</a></li><li class="category-list-item"><a class="category-list-link" href="/categories/Postfix/">Postfix</a></li><li class="category-list-item"><a class="category-list-link" href="/categories/Redis/">Redis</a></li><li class="category-list-item"><a class="category-list-link" href="/categories/Web/">Web</a></li><li class="category-list-item"><a class="category-list-link" href="/categories/Windows/">Windows</a></li><li class="category-list-item"><a class="category-list-link" href="/categories/Zabbix/">Zabbix</a></li></ul>
    </div>
  </div>


  
    

  
    
  
    
  <div class="widget-wrap">
    <h3 class="widget-title">Archives</h3>
    <div class="widget">
      <ul class="archive-list"><li class="archive-list-item"><a class="archive-list-link" href="/archives/2016/11/">November 2016</a></li><li class="archive-list-item"><a class="archive-list-link" href="/archives/2016/10/">October 2016</a></li><li class="archive-list-item"><a class="archive-list-link" href="/archives/2016/09/">September 2016</a></li><li class="archive-list-item"><a class="archive-list-link" href="/archives/2016/08/">August 2016</a></li><li class="archive-list-item"><a class="archive-list-link" href="/archives/2016/07/">July 2016</a></li><li class="archive-list-item"><a class="archive-list-link" href="/archives/2016/06/">June 2016</a></li><li class="archive-list-item"><a class="archive-list-link" href="/archives/2016/05/">May 2016</a></li><li class="archive-list-item"><a class="archive-list-link" href="/archives/2016/04/">April 2016</a></li></ul>
    </div>
  </div>


  
    
  <div class="widget-wrap">
    <h3 class="widget-title">Recent Posts</h3>
    <div class="widget">
      <ul>
        
          <li>
            <a href="/2016/11/26/Hadoop-新-MapReduce-框架-Yarn-详解/">Hadoop 新 MapReduce 框架 Yarn 详解</a>
          </li>
        
          <li>
            <a href="/2016/11/26/JobTracker-和-TaskTracker-概述/">JobTracker 和 TaskTracker 概述</a>
          </li>
        
          <li>
            <a href="/2016/11/26/浅谈-JobTracker-和-TaskTracker/">浅谈 JobTracker 和 TaskTracker</a>
          </li>
        
          <li>
            <a href="/2016/11/26/Hadoop-MapReduce/">Hadoop MapReduce</a>
          </li>
        
          <li>
            <a href="/2016/11/26/Hadoop-启动、关闭/">Hadoop 启动、关闭</a>
          </li>
        
      </ul>
    </div>
  </div>

  
</aside>
        
      </div>
      <footer id="footer">
  
  <div class="outer">
    <div id="footer-info" class="inner">
      &copy; 2016 XiaoYong Hu<br>
      Powered by <a href="http://hexo.io/" target="_blank">Hexo</a>
    </div>
  </div>
</footer>
    </div>
    <nav id="mobile-nav">
  
    <a href="/" class="mobile-nav-link">Home</a>
  
    <a href="/archives" class="mobile-nav-link">Archives</a>
  
    <a href="/About" class="mobile-nav-link">About</a>
  
</nav>
    

<script src="//ajax.googleapis.com/ajax/libs/jquery/2.0.3/jquery.min.js"></script>


  <link rel="stylesheet" href="/fancybox/jquery.fancybox.css">
  <script src="/fancybox/jquery.fancybox.pack.js"></script>


<script src="/js/script.js"></script>

  </div>
</body>
</html>